# 9장  제네릭스

9장에서 다루는 내용

■ 제네릭 함수와 클래스를 정의하는 방법

■ 타입 소거와 실체화한 타입 파라미터

■ 선언 지점과 사용 지점 변성

<aside>
💡 먼저, Java 제네릭에 대해서 정리해보겠다.

제네릭이란?

- 데이터 타입을 일반화 하는 것을 의미한다.
- 제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다.
- 이렇게 컴파일 시 type check를 하면 장점이 있다.
    - 클래스나 메소드 내부에서 사용되는 객체의 타입의 안정성을 높일 수 있다.
    - 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.

제네릭을 사용하는 이유

- 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일과정에서 제거할 수 있기 떄문이다.
- 실행 시 타입 에러가 나는 것보다 컴피알 시에 타입을 강하게 체크해서 에러를 사전에 방지하는 것이 좋다.
- 제네릭 코드를 사용하면 타입을 국한하기 때문에 요소를 찾아올 때 타입 변환을 할 필요가 없어 프로그램 성능이 향상되는 효과를 얻을 수 있다.

타입변수

- 아무런 이름이나 지정해도 컴파일하는데 전혀 상관이 없다.
- 현존하는 클래스를 사용해도 되고 존재하지 않는 것을 사용해도 된다.
- 임의의 참조형 타입을 의미한다.
- 꼭 T를 사용안하고 어떠한 문자를 사용해도 되지만 아래의 네이밍을 지켜주는 것이 좋다.
- 여러 개의 타입 변수는 쉼표(,)로 구분하여 명시할 수 있다.
- 타입 변수는 클래스에서뿐만 아니라 메소드의 매개변수나 반환값으로 사용할 수 있다.
</aside>

# 책 내용 정리

- 알고 있어야 하는 내용
    - variance : 변성 → 타입 인자의 상하 관계에 따라 제네릭 타입의 상하관계 처리도 영향받는다.
    - invariant : 무변성 → 타입 인자의 상하 관계가 제네릭 타입의 상하 관계와 관련 없다.
    - convariant : 공변성 → 타입 인자의 상하 관계가 제네릭 타입의 상하 관계와 같다.
    - contravariance : 반공변성 → 타입 인자의 상하 관계와 제네릭 타입의 상하 관계가 역전된다.
- 그외 정리한 내용
    - 실체화한 타입 파라미터
        - 실체화한 타입 파라미터를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체저적인 타입을 실행시점에 알 수 있다.
    - 선언 지점 변성
        - 기저 타입(=제네릭 타입에서 타입 파라미터를 제외한)은 같지만 타입 인자가 다른 두 제네릭타입이 있을 때 타입 인자 A와 타입 인자 B의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계를 지정할 수 있다.

## 요약

- 코틀린 제니릭스는 자바와 비슷한다. 제네릭 함수와 클래스를 자바와 비슷하게 선언할 수 있다.
- 자바와 마찬가지로 제네릭 타입의 타입 인자는 컴파일 시점에만 존재한다.
- 타입 인자가 실행 시점에 지워지므로 타입 인자가 있는 타입(제네릭 타입)을 is 연산자를 사용해 검사할 수 없다.
- 인라인 함수의 타입 매개변수를 reified로 표시해서 실체화하면 실행 시점에 그 타입을 is로 검사하거나 java.lang.Class 인스턴스를 얻을 수 있다.
- 변성은 기저 클래스가 같고 타입 파라미터가 다른 두 제네릭 타입 사이의 상위/하위 타입 관계가 타입 인자 사이의 상위/하위 타입 관계에 의해 어떤 영향을 받는지를 명시하는 방법이다.
- 제네릭 클래스의 타입 파라미터가 아웃 위치에서만 사용되는 경우(생산자) 그 타입 파라미터를 out으로 표시해서 공변적으로 만들 수 있다.
- 공변적인 경우와 반대로 제네릭 클래스의 타입 파라미터가 인 위치에서만 사용되는 경우(소비자) 그 타입 파라미터를 in으로 표시해서 반공변적으로 만들 수 있다.
- 코틀린의 읽기 전용 List 인터페이스는 공변적이다. 따라서 List<String>은 List<Any>의 하위 타입이다.
- 함수 인터페이스는 첫 번째 타입 파라미터에 대해서는 반공변적이고, 두 번째 타입 파라미터에 대해서는 공변적이다(다른 말로 하면 함수 타입은 함수 파라미터 타입에 대해서는 반공변적이며 함수 반환 타입에 대해서는 공변적이다.) 그래서 (Animal) → Int 는 (Cat) → Number의 하위 타입이다.
- 코틀린에서는 제네릭 클래스의 공변성을 전체적으로 지정하거나(선언 지점 변성), 구체적인 사용 위치에서 지정할 수 있다.(사용 지점 변성)
- 제네릭 클래스의 타입 인자가 어떤 타입인지 정보가 없거나 타입 인자가 어떤 타입인지가 중요하지 않을 때 스타 프로젝션 구문을 사용할 수 있다.

### 타입 파라미터 제약

- 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.

```kotlin
fun <T: Comparable<T>> max(first: T, second: T): T {
    return if (first > second) first else second
}
>>> println(max("kotlin", "java"))
kotlin
```

### 실행 시점의 제네릭 : 타입 검사와 캐스트

```kotlin
fun printSum(c: Collection<*>) {
    val intList = c as? List<Int>                 
            ?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
}
>>> printSum(listOf(1, 2, 3))               
6
```

### 실체화한 타입 파라미터를 사용한 함수 선언

```kotlin
inline fun <reified T> isA(value: Any) = value is T
>>> println(isA<String>("abc"))
true
>>> println(isA<String>(123))
false
```

```kotlin
inline fun <reified T>                          
        Iterable<*>.filterIsInstance(): List<T> {
    val destination = mutableListOf<T>()
    for (element in this) {
        if (element is T) {                    
            destination.add(element)
        }
    }
    return destination
}
```

### 변성 : 제니릭과 하위 타입

- 변성 개념은 List<String>와 List<Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.

### 클래스, 타입, 하위 타입

- 타입 사의의 관계를 논하기 위해 하위 타입 이라는 개념을 알아야 한다.
    - 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면 타입 B는 타입 A의 하위 타입이다.
    - 예를 들어 Int는 Number의 하위 타입이지만, String의 하위타입은 아니다.
    - 상위 타입(super type)은 하위 타입의 반대다. A타입이 B 타입의 하위타입이라면 B는 A의 상위 타입이다.
    - 제네릭 타입을 인스턴스화할때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입관계가 성립하지 않으면 그 제네릭 타입을 무공변이라고 말한다.
        - MutableList를 예로 들면 A와 B가 서로 다르기만 하면 MutableLIst<A>는 항상 MutableList<B>의 하위 타입이 아니다.

### 공변성 : 하위 타입 관계를 유지

- A가 B의 하위 타입일 때 Producer<A>가 Producer<B>의 하위 타입이면 Producer는 공변적이다.
    - Cat가 Animal의 하위 타입이기 때문에 Producer<Cat>은 Producer<Animal>의 하위 타입이다.
    - 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 한다.
    - 클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환값으로  사용할 수 있다.

### 반공변성 : 뒤집힌 하위 타입 관계

- in 이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼 메소드에 의해 소비된다는 뜻이다.
- 공변성의 경우와 마찬가지로 타입 파라미터의 사용을 제한함으로써 특정 하위 타입 관계에 도달할 수 있다.
- in 키워드를 타입 인자에 붙이면 그 타입 인자를 오직 인 위치에서만 사용할 수 있다는 뜻이다.

### 사용 지점 변성 : 타입이 언급되는 지점에서 변성 지정

- 클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼치므로 편리하다. 이런 방식을 선언 지점 변성이라 부른다.
- 자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 하위 타입이나 상위 타입중 어떤 타입으로 대치할 수 있는지 명시해야 한다. 이런 방식을 사용 지점 변성이라 한다.

## 제네릭 타입 파라미터

```kotlin
val authors = listOf("Dmitry", "Svetlana")
```

- listOf 함수에 전달된 두 값은 모두 문자열이기 때문에 컴파일러는 List<String>을 만들고 있다고 추론한다.

```kotlin
interface Comparable<T> {
    fun compareTo(other: T): Int
}

class String : Comparable<String> {
    override fun compareTo(other: String): Int = /* ... */
}
```

## 제네릭 함수와 프로퍼티

- 컬렉션을 다루는 함수는 대부분 제네릭 함수다.

```kotlin
public fun <T> List<T>.slice(indices: IntRange): List<T> {
    if (indices.isEmpty()) return listOf()
    return this.subList(indices.start, indices.endInclusive + 1).toList()
}
```

- 함수의 타입 파라미터 T가 수신 객체와 반환 타입에 쓰인다. 수신객체와 반환타입 모두 List<T>다.
- 컴파일러는 반환 타입 List<T>의 T를 자신이 추론한 Char로 치환한다.

## 제네릭 클래스 선언

타입 파마미터를 넣은 꺾쇠 기호(<>)를 클래스 또는 인터페이스 이름 뒤에 붙이면 제니릭하게 만들 수 있다.

```kotlin
interface List<T>{
    operator fun get(index: Int) : T
}
```